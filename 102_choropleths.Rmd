<style>@import url(style.css);</style>
[Introduction to Data Analysis](index.html "Course index")

# 10.2. Choropleth maps

The code in this section ends on a simple choropleth map. The operations covered before the final result includes common data import routines as well as a few replication plots.

```{r packages, message=FALSE}
packages <- c("downloader", "ggplot2", "maps", "RColorBrewer", "scales", "XML")
packages <- lapply(packages, FUN = function(x) {
  if(!require(x, character.only = TRUE)) {
    install.packages(x)
    library(x, character.only = TRUE)
  }
})
```

## Two-party vote shares in the United States

This example is based on an [example map][ds] by David Sparks. It shows how to map U.S. state-level electoral data [collected by David Wasserman][dw]. The next code block will start by downloading the data and importing a selection of rows and columns from the CSV file. The only noteworthy step is that we remove the District of Columbia to un-skew later distributions.

[ds]: http://is-r.tumblr.com/post/35200999886/make-your-own-electoral-map
[dw]: https://docs.google.com/spreadsheet/ccc?key=0AjYj9mXElO_QdHpla01oWE1jOFZRbnhJZkZpVFNKeVE#gid=0

```{r dw-grab}
# David Wasserman's data.
link = "https://docs.google.com/spreadsheet/pub?key=0AjYj9mXElO_QdHpla01oWE1jOFZRbnhJZkZpVFNKeVE&gid=0&output=csv"
# Download the spreadsheet.
if(!file.exists(file <- "data/wasserman.votes.0812.txt")) download(link, file, mode = "wb")
# Import selected rows.
dw <- read.csv(file, stringsAsFactors = FALSE, skip = 4)[-c(1:6, 19:20, 28), -c(4, 7:8)]
# Check result.
str(dw)
```

The next clode block cleans the dataset by removing punctuation and other text symbols from the variable names and values. It then adds a logical marker to discriminate the first twelve states in the data, which are marked as swing ("battleground") states.

```{r dw-clean}
# Fix dots in names.
names(dw) <- gsub("\\.\\.", "", names(dw))
# Remove characters.
dw <- data.frame(gsub("\\*|,|%", "", as.matrix(dw)), stringsAsFactors = FALSE)
# Make data numeric.
dw[, -1] <- data.matrix(dw[, -1])
# Create marker for swing states.
dw$Swing <- FALSE
# Mark first twelve states.
dw$Swing[1:12] <- TRUE
# Check result.
dw[1:15, ]
```

We imported the data without the precalculated two-party vote shares (VS), in order to run the formulas on our end. The first variable codes a state "blue" or "red" based on party victory. The last variable measures the size of the swing that would have been required for a given state to change hands (for Romney to win).

```{r dw-margins}
# Obama victory margins, using two-party vote.
dw  <- within(dw, {
  State_Color <- ifelse(Obama08 > McCain08, "Blue", "Red")
  # Margin in 2008.
  Total_VS_08 <- Obama08 + McCain08
  Obama_VS_08 <- 100 * Obama08 / Total_VS_08
  # Margin in 2012.
  Total_VS_12 <- Obama12 + Romney12
  Obama_VS_12 <- 100 * Obama12 / Total_VS_12
  # Obama swing in two-party vote share.
  Obama_Swing <- Obama_VS_12 - Obama_VS_08
  # Swing required for state to change hands.
  Rep_Wins <- 100 * (Romney12 - Obama12) / Total_VS_12
})
# Check results.
str(dw)
```

We now plot a first overview of the data, based on [Simon Jackman's analysis][sj] of similar figures. The list of swing states and the actual swings are slightly different in his visualization, and only one $x$-axis is scaled in our rendering because ggplot2 enforces the Stephen Few recommendation [against dual scales][sf]. The first grey line is the average swing in vote share in 2012. The black points are 

[sj]: http://jackman.stanford.edu/blog/?p=2620
[sf]: http://www.perceptualedge.com/articles/visual_business_intelligence/dual-scaled_axes.pdf

```{r dw-dotplot, fig.width = 9, fig.height = 12, tidy=FALSE}
# Order plot by states.
dw$State <- with(dw, reorder(State, Obama_Swing), ordered = TRUE)
# Dot plot.
ggplot(dw, aes(y = State, x = Obama_Swing)) +
  geom_vline(x = c(0, mean(dw$Obama_Swing)), size = 4, color = "grey95") +
  geom_point(aes(colour = ifelse(Obama08 > McCain08, "Dem", "Rep")), size = 5) +
  geom_point(data = subset(dw, Swing), aes(x = Rep_Wins), size = 5, shape = 1) +
  scale_x_continuous(breaks = -10:4) +
  scale_colour_manual("2008", values = brewer.pal(3, "Set1")[c(2, 1)]) +
  labs(y = NULL, x = NULL, title = "Obama Swing in Two Party Vote Share\n")
```

The last plot replicates part of the summary plot by [Simon Jackman][sj], showing the swing from 2008 to 2012 against Obama's vote share in 2008 weighted by electoral college votes. The first step for this plot is to get the number of electoral college voters per state as well as state abbreviations, both from Wikipedia. The data are merged to the principal data frame.

```{r dw-more-data}
# Electoral college votes, 2012.
url = "http://en.wikipedia.org/wiki/Electoral_College_(United_States)"
# Extract fifth table.
college <- readHTMLTable(url, which = 5, stringsAsFactors = FALSE)
# Keep first and last columns, removing total electors.
college <- data.frame(State = college[, 1], 
                      College = as.numeric(college[, 35]))
# Merge to main dataset.
dw <- merge(dw, college, by = "State")
# U.S. states codes.
url = "http://en.wikipedia.org/wiki/List_of_U.S._states"
# Extract fifth table.
uscodes <- readHTMLTable(url, which = 2, stringsAsFactors = FALSE)
# Keep first and last columns, removing total electors.
uscodes <- data.frame(State = uscodes[, 1],
                      Abbreviation = uscodes[, 4])
# Merge to main dataset.
dw <- merge(dw, uscodes, by = "State")
# Check result.
str(dw)
```

The final plot follows. It shows that Obama won by protecting the battleground states, losing only two states in the overall swing.

```{r dw-jackman-plot, warning=FALSE}
# Swing vs. Vote Share, weighted by Electoral College Votes.
ggplot(dw, aes(y = Obama_Swing, x = Obama_VS_08)) +
  geom_rect(xmin = 50, xmax = Inf, ymin = -Inf, ymax = Inf,
            alpha = .3, fill = "grey95") +
  geom_point(aes(color = Romney12 > Obama12, size = College), alpha = .6) +
  geom_text(colour = "white", 
            label = ifelse(dw$Swing, as.character(dw$Abbreviation), NA)) +
  scale_colour_manual("2008", values = brewer.pal(3, "Set1")[c(2, 1)]) +
  scale_size_area(max_size = 42) +
  labs(y = "Obama Swing in Two Party Vote Share", x = "Obama 2008 Vote Share") +
  theme(legend.position = "none")
```

## Mapping the electoral swing

To map the swing from 2008 to 2012, we load some geographical data and extract state names from the object. The method corresponds to the code provided by [David Sparks][ds]: it creates a map dataset provided by the `maps` package and adds the variables to it, aggregating them by states, which are called `region` in the `stateShapes` file formed rom the `maps` object.

```{r dw-map-adjust}
# Load state shapefiles.
stateShapes <- map("state", plot = FALSE, fill = TRUE)
# Convert shapes to a data frame.
stateShapes <- fortify(stateShapes)
# Extract states from map dataset.
uniqueStates <- sort(unique(stateShapes$region))
# Transpose data to map dataset.
stateShapes$Swing   <- by(dw$Obama_Swing, uniqueStates, mean)[stateShapes$region]
stateShapes$Obama08 <- by(dw$Obama_VS_08, uniqueStates, mean)[stateShapes$region]
stateShapes$Obama12 <- by(dw$Obama_VS_12, uniqueStates, mean)[stateShapes$region]
```

The plot is going to show quintiles of the Obama swing from 2008 to 2012. The quintiles, ordered from the lowest 20% to highest 20%, are calculated from a short function that calculates the quantiles of a variable and uses them to cuts the variable into categories (factorized groups). The function calculates quintiles by default.

```{r dw-quantile-function, fig.width = 9, fig.height = 5, tidy=FALSE}
# Prepare quintile function.
quantize <- function(x, q = 5) {
  cut(x, breaks = quantile(x, probs = 0:q/q, na.rm = TRUE), include.lowest = TRUE)
}
```

The final code for the maps is again heavy due to graph options. Most options are set to make the plot blank (no titles, no ticks, no axes, etc.). The coordinates are made conic to curve the map correctly. The first map shows the swing in vote share, and the second one shows the actual vote share.

```{r dw-map-choropleth, echo = FALSE, fig.width = 12, fig.height = 6.6, tidy=FALSE}
# Choropleth map for Obama swing vote.
ggplot(stateShapes, aes(x = long, y = lat, group = group, fill = quantize(Swing))) +
  geom_polygon(colour = "white") + coord_map(project = "conic", lat0 = 30) +
  scale_fill_brewer("", palette = "RdYlBu") + scale_colour_brewer(palette = "RdYlGn") +
  labs(y = NULL, x = NULL, title = "Swing (2012 - 2008) Obama vote share\n") +
  theme(panel.border = element_rect(color = "white"), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
# Choropleth map for Obama vote share.
ggplot(stateShapes, aes(x = long, y = lat, group = group, fill = quantize(Obama08, 10))) +
  geom_polygon(colour = "white") + coord_map(project = "conic", lat0 = 30) +
  scale_fill_brewer("", palette = "RdBu") + scale_colour_brewer(palette = "RdYlGn") +
  labs(y = NULL, x = NULL, title = "Obama vote share, 2008\n") +
  theme(panel.border = element_rect(color = "white"), 
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

David Sparks has also posted code for [simpler maps](http://is-r.tumblr.com/post/37708137014/us-state-maps-using-map-data) with less data wrangling, and [chloropleth maps](https://dsparks.wordpress.com/2011/02/21/choropleth-tutorial-and-regression-coefficient-plots/) with more precise data. In the future, there's a chance that he will also post his code for [isarithmic map](https://dsparks.wordpress.com/2012/07/18/mapping-public-opinion-a-tutorial/) that look like this:

[![Isarithmic map, by David Sparks.](images/cces-2008-family-income-black.png)](images/cces-2008-family-income-black.png)

> __Next:__ [Practice](103_practice.html).
